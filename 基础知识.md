在开始制作模组之前，我们先来了解下 KSP 的一些知识吧。

## KSP 和模组

一个模组主要分为两个部分：部件和游戏逻辑，除此之外还包括旗帜或者本地化文本之类的东西。

我们编写的模组需要在 KSP 上运行，KSP 使用 Unity 游戏引擎编写并使用了 Mono 这个跨平台的 .NET 实现作为底层运行环境（指南中我们只讨论 Windows 10 中的模组制作）。

KSP 和 Unity 大部分都是使用 C# 编写的，因此只有使用 C# 来编写游戏逻辑才能够很方便地和 KSP、Unity 相互调用。

> **KSP 使用的运行库版本（绕过坑）**
> 
> 编写和构建插件时必须使用 KSP 对应版本的运行库。下面的表格根据 KSP 根目录下的 `readme.txt` 中的更新日志整理。有问号标记的版本有一些疑问，有可能有错误。在指南中，我们只讨论 KSP v1.11.0（最新版本）和相关的运行库。
>
> | KSP 版本                   | Unity 版本     | .NET Framework 版本 |
> | -------------------------- | -------------- | ------------------- |
> | **v1.8.0 - v1.11.0**       | **2019.2.2f1** | **4.x**             |
> | v1.4.0 - v1.7.3            | 2017.1.3p1     | 3.5（？）           |
> | v1.2.0 - v1.3.1            | 5.4.0p4        | 3.5（？）           |
> | v1.1.3                     | 5.2（？）      | 未知                |
> | v1.1.1 - v1.1.2            | 5.1.1（？）    | 未知                |
> | v1.1.0                     | 5（？）        | 未知                |
> | v0.23.5.459 - v1.0.5       | 4.3（？）      | 未知                |
> | v0.23.0                    | 4.2.2（？）    | 未知                |
> | v0.18.4 RC1 - v0.22.0      | 4（？）        | 未知                |
> | v0.13.1x1 - v0.18.3 (Demo) | 最新（？）     | 未知                |
> | v0.7.3 - v0.13.1           | 未知           | 未知                |

> **VB.NET 可以用来写游戏逻辑吗？（无关紧要）**
>
> 由于 C# 和 VB.NET 编译出的 IL 可能没有太大区别且应该都能在 Unity 里运行。因此我们猜测理论上可以使用 VB.NET 来编写游戏逻辑，但由于没有测试过 VB.NET 的可用性且 Visual Studio Tools for Unity 只支持 C#，还是建议使用 C# 来编写。

## KSP 加载机制

当我们启动 KSP 开始读条时，KSP 会先加载必要的组件，接着加载部件等资源。KSP 会在 `GameData/` 文件夹下寻找所有 `.dll`（托管的）和 `.cfg` 文件并尝试加载它们。

> **点击调试工具栏的 `数据库` 页面中的 `重新加载数据库` 按钮时会也会这样吗？（绕过坑）**
>
> 此时会重新加载**除了 `.dll` 以外**的 `.cfg` 等文件。

## 模组加载机制

当 KSP 加载一个 `.dll` 文件时，它会加载以下这些类：

- 继承自 `MonoBehavior` 并拥有 `KSPAddon` 特性

- 继承自 `ScenarioModule` 并拥有 `KSPScenario` 特性

- 继承自 `VesselModule`

- 继承自 `PartModule`

KSP 加载完这些类之后就会在发生特定事件时执行对应类中对应的方法。

> **参考**
> 
> - [编写插件的基础知识](https://forum.kerbalspaceprogram.com/index.php?/topic/153765-getting-started-the-basics-of-writing-a-plug-in/)（KSP 论坛，英文）

> **为什么不能用构造方法和析构方法？（绕过坑）**
>
> KSP 在加载部件后会立即创建一个预制部件，需要使用部件时再将预制部件复制为新的部件。Unity 引擎中复制部件是通过将对象序列化再反序列化来实现的，因此类的构造方法和析构方法可能不会按预期运行。我们应该使用 `Start` 和 `OnDestroy` 来替代构造方法和析构方法（后面会具体讲到）。

## 部件加载机制

当 KSP 加载一个部件（`.cfg` 文件）时，它会尝试寻找并加载文件中的 `PART` 节点。`PART` 节点中记录了一个部件的各种信息，包括名称、资源文件位置、游戏逻辑等。接着 KSP 就会加载在 `.cfg` 文件中指定的模型、贴图等文件。当它们被成功加载时，一个部件就会出现在 KSP 中。

KSP 还会加载 `PART` 节点中的 `MODULE` 节点，每一个 `MODULE` 节点都有一个 `name` 属性。加载 `MODULE` 节点时 KSP 会尝试在已加载的类中寻找这个 `name` 属性对应名称的继承自 `PartModule` 的类。每一个部件中每一个 `MODULE` 节点都对应一个类实例，之后 KSP 就会在部件发生特定事件时执行对应类中对应的方法。

> **参考**
> 
> - [部件生命周期](https://forum.kerbalspaceprogram.com/index.php?/topic/145340-the-lifecycle-of-a-part-module-a-primer/)（KSP 论坛，英文）

我们从前文可以看出，添加或修改部件可以通过编写 `.cfg` 文件和对应的资源文件来实现，添加或修改游戏逻辑可以通过编写 C# 程序来实现。
